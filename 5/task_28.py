# Задача 28: Напишите рекурсивную функцию sum(a, b),
# возвращающую сумму двух целых неотрицательных чисел. Из
# всех арифметических операций допускаются только +1 и -1.
# Также нельзя использовать циклы.

a = int(input('Enter a: '))
b = int(input('Enter b: '))

def f(a, b):
    if b < 0:
        return 0
    return a + f(1,b - 1)

print('Summa = ', f(a, b))


# Яна Постникова ##########################################################################
# # Задача 1 необязательная. Напишите рекурсивную программу вычисления
# # арифметического выражения заданного строкой. Используйте операции +,-,/,*.
# # приоритет операций стандартный.
#
# # *Пример:*
# # 2+2 => 4;
# # 1+2*3 => 7;
# # 1-2*3 => -5;
#
# # - Добавьте возможность использования скобок, меняющих приоритет операций.
#
# # *Пример:*
# # 1+2*3 => 7;
# # (1+2)*3 => 9;
# # Тут может помочь библиотека re
#
# ##########################################################################
# # задача Де моргана необязательная
#
# # Напишите программу для. проверки истинности утверждения
# # ¬(X ⋁ Y ⋁ Z) = ¬X ⋀ ¬Y ⋀ ¬Z для всех значений предикат.
#
# # теперь надо проверить ее практически
# # в цикле 100 раз прогоняем
# # каждый раз генерируем случайное количество предикат от 3 до 15
# # и конечно со случайным булевым значением
# # и засекаем общее время выполнения программы
# # юзаем библиотеки random и time
# # предикаты НЕ ЗАДАЕМ как целое число!
#
# # например, при первом эксперименте количество предикат сгенерировалось
# # равным 4
# # тогда получили 4 предикаты со случайным значением [True, False, False, True]
# # проверили равенство левой части и правой части теоремы де Моргана
# # применительно к этим предикатам, если все ок, то переходим к другому
# # эксперименту, если теорема нарушается, то вывести всю информацию об этом
#
# # в конце написать сколько времени отработал ваш код